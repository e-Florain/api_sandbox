* Terminologie
** Bases de données
- Base Maison :: base de données contenant tous les adhérents créée et
     maintenue par nos soins. techno à définir : PostgreSQL ? MangoDB ?
- Base Cyclos :: base de données spécifique Cyclos,

** TODO Composants logiciels
- API HelloAsso
- API Cyclos
- Connecteur HelloAsso

#+begin_src dot :file change.png :cmd circo :cmdline -Tpng :exports none :results drawer
  digraph G { Connexion_Cyclos -> redirection_vers_HA -> paiement ->
  HA_POST_vers_Maison -> Maison_POST_vers_Cyclos }
#+end_src

#+RESULTS:
:RESULTS:
[[file:change.png]]
:END:

* Tests en vracs API en Python
Afin de faire des requêtes sur une API REST, il y a une super
bibliothèque : "requests".

** Documentation :
https://requests.readthedocs.io/en/master/

** Installation :
 De mon coté je n'ai rien eu à faire sous Pop_os 18.04.

** Bac à sable
#+begin_src ipython :session api :file  :exports code
import requests
#+end_src

#+RESULTS:
: # Out[4]:

Afin de me faire la main, je vais utiliser une API ouverte :
http://open-notify.org/ qui met à disposition une partie des données
de la NASA.

Cette API, comme toutes les APIs mettent à disposition des URLs
permettant d'accéder à des données spécifiques. J'ai trouvé une URL
permettant de récupérer la liste des astronautes actuellement dans
l'espace :
http://api.open-notify.org/astros.json

Ici, on effectue la requête et on récupère la réponse.
#+begin_src ipython :session api :file  :exports both :results output
r = requests.get("http://api.open-notify.org/astros.json")
print(type(r))
#+end_src

#+RESULTS:
: <class 'requests.models.Response'>

Très bien, mais qu'en fait-on ?

On peut déjà commencer par vérifier le code de statut.

#+begin_src ipython :session api :file  :exports both :results output
print(r.status_code)
#+end_src

#+RESULTS:
: 200

#+caption: codes de statuts
| Category           | Description                                                                                           |
|--------------------+-------------------------------------------------------------------------------------------------------|
| 1xx: Informational | Communicates transfer protocol-level information.                                                     |
| 2xx: Success       | 	Indicates that the client’s request was accepted successfully.                                |
| 3xx: Redirection   | 	Indicates that the client must take some additional action in order to complete their request. |
| 4xx: Client Error  | 	This category of error status codes points the finger at clients.                             |
| 5xx: Server Error  | The server takes responsibility for these error status codes.                                           |

Exploitation des données récupérées :

Le contenu de la réponse est une chaîne de caractères non encodée.  La
méthode '.json()' permet de récupérer un dictionnaire python, qui sera
par la suite facilement exploitable. Ici on ne fait que l'afficher.
#+begin_src ipython :session api :file  :exports both :results output
import pprint
pprint.pprint(r.json())
#+end_src

#+RESULTS:
: {'message': 'success',
:  'number': 3,
:  'people': [{'craft': 'ISS', 'name': 'Chris Cassidy'},
:             {'craft': 'ISS', 'name': 'Anatoly Ivanishin'},
:             {'craft': 'ISS', 'name': 'Ivan Vagner'}]}

Plus compliqué, une requête avec des paramètres. Toujours sur
open-notify, on trouve une adresse permettant de récupérer les
prochaines dates de passages de l'ISS au dessus d'un couple de
coordonnées (LAT, LON). Le code ci dessous permet d'obtenir
l'équivalent de cette requête :
http://api.open-notify.org/iss-pass.json?lat=40.71&lon=-74

Le passage de paramètres est ainsi simplifié en utilisant un
dictionnaire python.
#+begin_src ipython :session api :file  :exports both :results output
parameters = {"lat": 48.684426, "lon": 6.171111}
r = requests.get("http://api.open-notify.org/iss-pass.json", params=parameters)
pprint.pprint(r.json())
#+end_src

#+RESULTS:
#+begin_example
{'message': 'success',
 'request': {'altitude': 100,
             'datetime': 1587598611,
             'latitude': 48.684426,
             'longitude': 6.171111,
             'passes': 5},
 'response': [{'duration': 544, 'risetime': 1587617490},
              {'duration': 651, 'risetime': 1587623210},
              {'duration': 652, 'risetime': 1587629021},
              {'duration': 654, 'risetime': 1587634845},
              {'duration': 642, 'risetime': 1587640656}]}
#+end_example

Conversion des timestamps en dates humainement compréhensibles :
#+begin_src ipython :session api :file  :exports both
from datetime import datetime
data = r.json()
dates = [str(datetime.fromtimestamp(d['risetime'])) for d in data['response']]
dates
#+end_src

#+RESULTS:
: # Out[36]:
: #+BEGIN_EXAMPLE
:   ['2020-04-23 06:51:30',
:   '2020-04-23 08:26:50',
:   '2020-04-23 10:03:41',
:   '2020-04-23 11:40:45',
:   '2020-04-23 13:17:36']
: #+END_EXAMPLE

* Connecteur HelloAsso

** Exemple simple
#+begin_src ipython :session api :file  :exports code :tangle hello.py
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'
#+end_src

#+BEGIN_SRC bash
export FLASK_APP=hello.py
flask run
#+END_SRC

#+begin_src ipython :session api :file  :exports both
r = requests.get("http://127.0.0.1:5000/")
r.status_code, r.text
#+end_src

#+RESULTS:
: # Out[7]:
: : (200, 'Hello, World!')

Ok, on a un serveur qui sait répondre à une requête GET simple.

#+begin_src python :tangle server.py
from flask import request
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.form.to_dict()
        print(data)
        return {'coucou': 'coucoutext'}
    else:
        return 'coucou'
#+end_src

#+RESULTS:
: # Out[9]:

#+begin_src ipython :session api :file  :exports both
data = {'key1': 42}
r = requests.post("http://127.0.0.1:5000/login", data=data)
r.status_code, r.json()
#+end_src

#+RESULTS:
: # Out[21]:
: : (200, {'coucou': 'coucoutext'})

** URL de callback HelloAsso

Il est possible de paramétrer le site HelloAsso afin qu'il effectue
une requête POST sur une URL spécifique.

"Les notifications sont réalisées via des requêtes sous format
URLEncoded et en POST sur les urls que vous aurez définies pour chacun
des types de notification décrits dans ce chapitre."
https://dev.helloasso.com/v3/notifications

Ici sont présentées les données qui sont transmises lors d'un nouveau paiement.
| Paramètre        | 	Description                                                        | 	Format  |
|------------------+----------------------------------------------------------------------------+-----------------|
| id 	      | L’identifiant du paiement                                                  | 	string  |
| date 	    | La date                                                                    | 	string  |
| amount           | 	Le montant du paiement                                             | 	decimal |
| type 	    | Type de paiement paiement                                                  | 	string  |
| url 	     | L’url de la campagne sur laquelle a été effectué le paiement               | 	string  |
| payer_first_name | 	Le prénom du payeur                                                | 	string  |
| payer_last_name  | 	Le nom du payeur                                                   | 	string  |
| url_receipt      | 	L’url du reçu                                                      | 	string  |
| url_tax_receipt  | 	L’url du reçu fiscal 	                                      | string          |
| action_id        | 	Action ID à requeter pour les infos complémentaires 	string |                 |

Attention, il semblerait qu'un seul paiement d'un utilisateur sur le
site puisse déclencher plusieurs appels du callback. En effet,
l'utilisateur peut payer pour ce qu'il achète ET faire un don dans la
même procédure.

La rubrique "format des responses" stipule que le paiement peut avoir
plusieurs actions :

#+begin_example
{
	"id": "string",
	"date": "date",
	"amount": "decimal",
	"type" : "string",
	"payer_first_name": "string",
	"payer_last_name": "string",
	"payer_address": "string",
	"payer_zip_code": "string",
	"payer_city": "string",
	"payer_country": "string",
	"payer_email": "string",
	"payer_birthdate": "date",
	"payer_citizenship": "string",
	"payer_society": "string",
	"payer_is_society": "bool",
	"url_receipt": "string",
	"url_tax_receipt": "string",
	"status": "string",
	"actions": [
	    {
	    "id": "string",
	    "type": "string",
	    "amount": "decimal"
	    }
	    …
	]
}
#+end_example

Or la notification de nouveau paiement ne comporte qu'un seul ID. Il
  semblerait donc que lorsqu'un utilisateur effectue une inscription
  ET un don, la notification est envoyé une fois par action. Ce qui
  est plutôt pratique car cela permettrait de savoir s'il faut
  créditer ou simplement remercier la personne.

Autre point important, Il va falloir trouver une solution pour
identifier de manière sure (et automatique) la personne qui à payé. En
effet, pour effectuer une adhésion, il faut remplir MANUELLEMENT
prénom et nom.

Il y a deux cas de figures :
- Première Adhésion :: ou les informations rentrées par l'utilisateur
  serviront de référence pour l'ajout dans les différentes bases de données

- Ré-adhésion/Paiement d'un adhérent :: il va falloir
  s'assurer d'une manière ou d'une autre de retrouver la bonne
  personne dans la base de données Maison.

Solutions envisagées :
- Peut être attribuer un identifiant utilisateur à rentrer ?
- envoyer les utilisateurs existants sur une page pré-remplie ?


Il va falloir prévoir de quoi gérer les cas où une personne s'est trompée,

  https://dev.helloasso.com/v3/responses#paiements
** Cyclos

https://demo.cyclos.org/api

https://demo.cyclos.org/api/system/payments
*** Authentification

#+begin_src ipython :session api :file  :exports both
  r = requests.get("https://demo.cyclos.org/api/auth",
                   auth=('virgile', 'virgile'))
  r.status_code, r.json()
#+end_src

#+RESULTS:
: # Out[15]:
: : (401, {'code': 'login'})

Démarrage d'une session
#+begin_src ipython :session api :file  :exports both
  r = requests.post("https://demo.cyclos.org/api/auth/session",
                   auth=('virgile', '4242'))
  r.status_code, r.json()
#+end_src

#+RESULTS:
: # Out[12]:
: : (401, {'code': 'login'})
